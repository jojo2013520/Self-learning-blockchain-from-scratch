孤荷凌寒自学第108天
区块链编程第23天以太坊智能合约002
【主要内容】
今天开始准备进行eth平台相关开发的基础学习，学习共用时28分钟。
（此外整理作笔记花费了约64分钟）
详细学习过程见文末学习过程屏幕录像。
今天的学习基本没有进展，但收获还是有的，明白了要进行ETH智能合约开发，还是得学习它的官方编程语言：Solidity
今天找到Solidity中文版的官方文档，尝试学习，发现难度非常大，只有很少一点收获 。

【学习笔记】
一、基础知识
（一）智能合约
这个名词一直以来都没有完全理解，今天专程查看百度百科，解释得很深奥，连猜带蒙，算是有了最简单的理解。
百度百科的解释是：
https://baike.baidu.com/item/%E6%99%BA%E8%83%BD%E5%90%88%E7%BA%A6/19770937?fr=aladdin
智能合约（英语：Smart contract ）是一种旨在以信息化方式传播、验证或执行合同的计算机协议。智能合约允许在没有第三方的情况下进行可信交易，这些交易可追踪且不可逆转。智能合约概念于1995年由Nick Szabo首次提出。
智能合约的目的是提供优于传统合约的安全方法，并减少与合约相关的其他交易成本。

相关概念：
数字形式意味着合约不得不写入计算机可读的代码中。这是必须的，因为只要参与方达成协定，智能合约建立的权利和义务，是由一台计算机或者计算机网络执行的。
【数字形式】我的理解就是，智能合约的源代码是开源保存的，则数字形式就是源代码本身。
更进一步地说明：
（1）达成协定
智能合约的参与方什么时候达成协定呢？答案取决于特定的智能合约实施。一般而言，当参与方通过在合约宿主平台上安装合约，致力于合约的执行时，合约就被发现了。
【达成协议】我的理解就是，只要接受这个智能合约，那么就可以成为此合约的一个网络节点，成为了网络节点，对这个智能合约来说，就算是被认可了。
（2）合约执行
“执行”的真正意思也依赖于实施。一般而言，执行意味着通过技术手段积极实施。
【合约执行】我的理解就是，比如用比特币的合约来进行交易操作，在交易发送与接收过程中，合约就在执行。
（3）计算机可读的代码
另外，合约需要的特定“数字形式”非常依赖于参与方同意使用的协议。
【数字形式】我的理解就是，智能合约的源代码是开源保存的，则数字形式就是源代码本身。

（二）两个关键的单词（我之前不认识这两个单词）
balances
指一个地址（区块链网络上的一人节点地址）上的代币余额。
contract
合约
在Solidity语言脚本中，使用这个单词作关键字，来定义一个智能合约。

二、分析一个最简单的Solidity的智能合约代码
官方文档：
https://solidity-cn.readthedocs.io/zh/develop/
中文版：
http://wiki.jikexueyuan.com/project/solidity-zh/types.html
下面的代码来自中文版简介的原文中。
```
// contract 建构一个智能合约 ，这个关键字后面的是合约 命名
contract SimpleStorage {
uint storedData;
//uint是一种数据类型，256位的无符号整数 
//则这儿的变量：storedData 就成为了合约的状态存储器（即用于存储合约的数据部分）

	//set方法将调用合约者传递的形参x对应的实参值赋予状态数据存储器storedData
    function set(uint x) {
        storedData = x;
    }

	//get方法将当前状态数据存储器storedData中的值返回给合约调用者
    function get() constant returns (uint retVal) {
        return storedData;
    }
}

```
在上面的例子中，这个合约就有一个合约框架与合约的具体数据存储两部分组成。

三、分析一个可以铸币的智能合约代码
下面的代码也来自于上面中文版文档的原文中。
```

//这个智能合约的命名为：Coin
contract Coin {
//下一行的关键字“public”使变量能从合约外部访问。address是一种数据类型
address public minter;
//address这种数据类型一般用于存储eth网络的地址，节点的公钥和私钥等。

//下一行的关键字“public”使变量能从合约外部访问。mapping是一种数据类型
mapping (address => uint) public balances;
//mapping可以被认为是一个哈希表，每一个可能的key对应的value被虚拟的初始化为全0.这个类比不是很严谨，对于一个mapping，无法获取一个包含其所有key或者value的链表。所以我们得自己记着添加了哪些东西到mapping中。
//在上一行中，address => unit 表示将地址【映射为uint类型】，因此mapping就成了一个二维表样式的对应哈希表。
//符号 => 表示 映射。


//下一行定义了一个事件，事件让轻客户端能高效的对变化做出反应。
event Sent(address from, address to, uint amount);
//我的理解是，这就是一个全网广播，告诉所有节点，有什么交易在进行。
//批注者：孤荷凌寒，qq：578652607，恳请提供指导，不胜感激
//其它任何一个节点可以通过监听此事件来了解当前区块链网络上合约的执行状态。

//下一行的这个函数方法的命名与当前智能合约体的命名完全一样，这是建构函数
function Coin() {
//智能合约的构造函数的代码仅仅只在合约创建的时候被运行一次，仅一次。
        minter = msg.sender;
		//上一行，初始化合约内部变量地址为调用此合约者的网络节点的地址
		//msg这个全局变量中包含了所有与调用合约者的网络节点相关的信息。
		//msg.sender就表示调用合约者的网络节点的地址
		//我的理解是，此处是在智能合约的建构函数中执行的，此建构函数方法只执行一次，那么，此处的msg.sender就是合约创建者节点（创世节点？）的地址。
		//批注者：孤荷凌寒，qq：578652607，恳请提供指导，不胜感激
}


function mint(address receiver, uint amount) {
		//我的理解是此函数将收到的形参的接收者地址receiver中的币的数量增加amout个，但却不减少发送方的币的数量，因为这儿根本就没有发送方。
		//这是因为下一行给我们指定了调用此合约中的此函数方法的节点地址必须是此合约的创建节点地址才能执行此函数方法
        if (msg.sender != minter) return;
        balances[receiver] += amount;
		//最终我的理解是这个函数方法应当是此合约的创建者在最开始时就中饱私囊的专用方法吧。
//批注者：孤荷凌寒，qq：578652607，恳请提供指导，不胜感激

}

//下一个函数方法是任何节点地址都可以调用的，用于实现代币的转移交易
function send(address receiver, uint amount) {
		//下一行先检查当前调用合约的节点（在此次交易中充当发送方）
		//的钱包中是否有足够多的余额amount，如果没有就返回FALSE
        if (balances[msg.sender] < amount) return;
		//下边两行，用于实现代币的转移，从一个节点地址转移到另一个节点地址。
        balances[msg.sender] -= amount;
        balances[receiver] += amount;
		//下面调用sent事件，广播此此交易，我的理解 
        Sent(msg.sender, receiver, amount);
		//批注者：孤荷凌寒，qq：578652607，恳请提供指导，不胜感激
    }
}
```

四、智能合约结构中的定义部分的简单认识
根据以下博文的描述：
http://wiki.jikexueyuan.com/project/solidity-zh/introduction-smart-contracts.html
我认识到——
1.
在智能合约结构中最上面的定义部分，其实真正解释执行时也被作为了函数来处理，不过是系统架构自动将定义语句转换为隐藏的函数来执行的。
2.
如：
address public minter;
其实真正执行时是下面的自动生成的隐藏函数：
function minter() returns (address) { return minter; }
上一行代码中，创建了一个函数，命名为： minter ,就是我们定义的变量 minter；
然后【returns (address)】语句表示此函数的返回值的类型是：address数据类型；
此函数体中，只一个语句，就是返回minter值，我注意到此处，不像python语言那样，要引用self之类的，可见在Solidity语言中，一个代码结构体中内部元素是可以自由引用的。
3.
如：
mapping (address => uint) public balances;
其实真正执行时，变成了下面的函数：
function balances(address _account) returns (uint balance) {
    return balances[_account];
}

在上面的函数中，将返回每人指定地址_account中的代币余额balances.


【学习后记】
我不清楚eth的合约开发为什么一定要限定使用Solidity语言，这种语言对于我来说是完全全新的，虽然从语法结构上来讲它像是c语言与javascript的杂糅体，还有点熟悉的感觉，但我本着学习Python而来，却不得不学习Solidity语言，顿时感觉有些茫然。
不知道eos基础上的开发与trx基础上的开发是否可以使用纯的python语言来实现？
甚至于我想，为什么写智能合约非得用上这么复杂 的代码呢，用人类的自然语言写那要有多好，届时，区块链技术必定会有大的爆发。

github: https://github.com/lhghroom/Self-learning-blockchain-from-scratch 
原文地址：http://www.941xue.com/content.aspx?id=1403  

【欢迎大家加入[就是要学]社群】
如今，这个世界的变化与科技的发展就像一个机器猛兽，它跑得越来越快，跑得越来越快，在我们身后追赶着我们。
很多人很早就放弃了成长，也就放弃了继续奔跑，多数人保持终身不变的样子，原地不动，成为那猛兽的肚中餐——当然那也不错，在猛兽的逼迫下，机械的重复着自我感觉还良好地稳定工作与生活——而且多半感觉不到这有什么不正常的地方，因为在猛兽肚子里的是大多数人，就好像大多数人都在一个大坑里，也就感觉不出来这是一个大坑了，反而坑外的世界显得有些不大正常。
为什么我们不要做坑里的大多数人？
因为真正的人生，应当有百万种可能 ；因为真正的一生可以有好多辈子组成，每一辈子都可以做自己喜欢的事情；因为真正的人生，应当有无数种可以选择的权利，而不是总觉得自己别无选择。因为我们要成为一九法则中为数不多的那个一；因为我们要成为自己人生的导演而不是被迫成为别人安排的戏目中的演员。
【请注意】
就是要学社群并不会告诉你怎样一夜暴富！也不会告诉你怎样不经努力就实现梦想！
【请注意】
就是要学社群并没有任何可以应付未来一切变化的独门绝技，也没有值得吹嘘的所谓价值连城的成功学方法论！
【请注意】
社群只会互相帮助，让每个人都看清自己在哪儿，自己是怎样的，重新看见心中的梦想，唤醒各自内心中的那个英雄，然后勇往直前，成为自己想要成为的样子！
期待与你并肩奔赴未来！
www.941xue.com 
QQ群：646854445 （【就是要学】终身成长）
 


【同步语音笔记】
https://www.ximalaya.com/keji/19103006/263134113

【学习过程屏幕录屏】
链接：https://pan.baidu.com/s/19Jam5vOsmn5rvDa33AsUiA 
提取码：11bi 

