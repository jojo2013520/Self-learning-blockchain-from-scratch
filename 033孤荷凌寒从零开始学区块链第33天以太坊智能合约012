孤荷凌寒自学第119天区块链033
以太坊的 erc20代币03
【主要内容】
今天继续使用erc20标准规范按一篇网络博文的教程进行亲自敲打代码来写一个可以发行token的智能合约。学习共用时35分钟。
（此外整理作笔记花费了约54分钟）
详细学习过程见文末学习过程屏幕录像。

【学习笔记】
一、今天没有理解问题放到开头，提醒自己再去阅读理解下
智能合约中的aprove授权操作现在感觉非常难以理解，在学习的当前代码中，几乎无法理解这个发出授权的节点与接受授权的节点究竟是怎么回事，这个方面的具体细节理解还得多去读相关论文或资料。

二、今天继续逐字母敲打书写作为基础的那个智能合约的内容。
到今天为止【StandardToken.sol】文件已完成的代码如下：
```
pragma solidity ^0.4.4;

import "Token.sol";

contract StandardToken is Token{
    mapping (address => uint256) balances;
    mapping (address => mapping (address => uint256)) allowed;
    uint256 public totalSupply;
    function transfer(address _to,uint256 _value) returns (bool success){
        //此函数仅用于调用合约的节点（或者理解为创建这个合约的节点？)地址进行代币的发送到_to形参指定的节点地址。
        //可以发送的代币的数量_value这个形参的数值类型是 uint256，可以理解为只能是大于等于零的数，且最大值为2^256-1（为什么要减一呢？因为从0开始）
        //实际上这个形参的数值类型就限定了最大可以发送的代币的数量，最多只允许2^256-1。
        //下一行代码要进行发送方现有代币余额的检查，以确认可以发送这么多的代币。
        if balances[msg.sender]>=_value && _value>0{
            //--如果发送方节点有这么多_value，那么执行代币在两个节点间的转移
            balances[msg.sender]-=_value;
            balances[_to]+=_value;
            //---触发事件----
            Transfer(msg.sender,_to,_value);
            //--返回处理结果----
            return true;
        }else{
            return false;
        }

    }

    function transferFrom(address _from,address _to,uint256 _value) returns (bool success){
        //此函数形参_from指定的节点地址进行代币的发送到_to形参指定的节点地址。(是否是在进行授权节点（合约的节点？）的代币支配转移？)
        //可以发送的代币的数量_value这个形参的数值类型是 uint256，可以理解为只能是大于等于零的数，且最大值为2^256-1（为什么要减一呢？因为从0开始）
        //实际上这个形参的数值类型就限定了最大可以发送的代币的数量，最多只允许2^256-1。
        //下一行代码要进行发送方现有代币余额的检查，以确认可以发送这么多的代币。
        //同时检查，发送方授权给授权接受方的可支配代币金额是否大于等于_value
        if balances[_from]>=_value && allowed[_from][msg.sender]>=_value && _value>0{
            //allowed[_from][msg.sender]中：
            //_from指的是代币真正的发送方（此节点代币才真正减少），而[msg.sender]指的是_from授权的接受节点（此节点可以动用_from节点限定数量的_value）
            //为什么这儿的授权接受方是[msg.sender]没有完全理解 。
            //--如果发送方节点有这么多_value，那么执行代币在两个节点间的转移
            balances[_from]-=_value; //真正发送代币的节点的代币数量减少
            balances[_to]+=_value; //接收代币的节点代币数量增加
            allowed[_from][msg.sender]-=_value; //授权的可动用的代币数量也减少
            //---触发事件----
            Transfer(_from,_to,_value);
            //--返回处理结果----
            return true;
        }else{
            return false;
        }

    }

    function balanceOf(address _owner) constant returns (uint256 balance){
        //此合约函数用于外部调用合约时，返回指定节点_owner目前的代币余额。
        return balance[_owner]
    }

}

```

【今天给大家分享的这些年我的自学感受】
自学能力是人持续的成长的发动机
这一点得分解成两个方面来谈。
一方面人是需要持续成长的。肯定的多数朋友要说——我早就长大了，甚至都长老了，还要成长，长成巨人不成？
此处的成长指的当然不是身体外形的成长，而指的人类独有的心智的成长。
如果把一个人比作计算机，那么心智就是运行在这台电脑里的操作系统以及其中许许多多的应用程序，用过的电脑的朋友都应当知道，不管是操作系统还是应用程序总是需要不断升级的——这就是心智的逐渐变化成长的过程。
另一方面对于人来说，只有自学才能实现不断的成长，把自学的能力看作人心智成长的发动机是再恰当不过的比喻了，试想，一部车子，如果没有发动机，那车子肯定就再也不能动了——对于人，那就是一介废人了。


github: https://github.com/lhghroom/Self-learning-blockchain-from-scratch 
原文地址：https://www.941xue.com/content.aspx?id=1493  
【欢迎大家加入[就是要学]社群】
如今，这个世界的变化与科技的发展就像一个机器猛兽，它跑得越来越快，跑得越来越快，在我们身后追赶着我们。
很多人很早就放弃了成长，也就放弃了继续奔跑，多数人保持终身不变的样子，原地不动，成为那猛兽的肚中餐——当然那也不错，在猛兽的逼迫下，机械的重复着自我感觉还良好地稳定工作与生活——而且多半感觉不到这有什么不正常的地方，因为在猛兽肚子里的是大多数人，就好像大多数人都在一个大坑里，也就感觉不出来这是一个大坑了，反而坑外的世界显得有些不大正常。
为什么我们不要做坑里的大多数人？
因为真正的人生，应当有百万种可能 ；因为真正的一生可以有好多辈子组成，每一辈子都可以做自己喜欢的事情；因为真正的人生，应当有无数种可以选择的权利，而不是总觉得自己别无选择。因为我们要成为一九法则中为数不多的那个一；因为我们要成为自己人生的导演而不是被迫成为别人安排的戏目中的演员。
【请注意】
就是要学社群并不会告诉你怎样一夜暴富！也不会告诉你怎样不经努力就实现梦想！
【请注意】
就是要学社群并没有任何可以应付未来一切变化的独门绝技，也没有值得吹嘘的所谓价值连城的成功学方法论！
【请注意】
社群只会互相帮助，让每个人都看清自己在哪儿，自己是怎样的，重新看见心中的梦想，唤醒各自内心中的那个英雄，然后勇往直前，成为自己想要成为的样子！
期待与你并肩奔赴未来！
www.941xue.com 
QQ群：646854445 （【就是要学】终身成长）
 




【同步语音笔记】
https://www.ximalaya.com/keji/19103006/268557115 

【学习过程屏幕录屏】
链接：https://pan.baidu.com/s/17ae9qFlEZy1MATN8_rNh0w 
提取码：1c3j

